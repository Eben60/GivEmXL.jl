var documenterSearchIndex = {"docs":
[{"location":"create-from-template/#Creating-a-project-from-template","page":"Creating project from template","title":"Creating a project from template","text":"","category":"section"},{"location":"create-from-template/","page":"Creating project from template","title":"Creating project from template","text":"using GivEmXL: makeproj\n\nmakeproj(\"/my_projects/MyProject/\", \"MyProject\", \"scrpt\"; authors=[\"1st author\", \"2nd author\"])","category":"page"},{"location":"create-from-template/","page":"Creating project from template","title":"Creating project from template","text":"This will create a GivEmXL based project from the default template. The project will be named MyProject and put into the folder /my_projects/MyProject/, with scripts named scrpt.sh and scrpt.bat, among other things. ","category":"page"},{"location":"create-from-template/","page":"Creating project from template","title":"Creating project from template","text":"using GivEmXL: makeproj\n\nmakeproj(\"/my_projects/MyToyProject/\", \"MyToyProject\", \"rcex2\", :example1; authors=[\"1st author\", \"2nd author\"])","category":"page"},{"location":"create-from-template/","page":"Creating project from template","title":"Creating project from template","text":"will create a project based on our Toy Example #1. See also makeproj documentation.","category":"page"},{"location":"create-from-template/#Referring-to-other-in-house-julia-projects-in-your-project","page":"Creating project from template","title":"Referring to other in-house julia projects in your project","text":"","category":"section"},{"location":"create-from-template/","page":"Creating project from template","title":"Creating project from template","text":"Our aim is that the only thing the end user will have to do to set up the environment would be simply running instantiate.bat (resp. instantiate.sh) once. If your project refers to some in-house projects, not registered in the General Registry, you can simply copy these projects into a subfolder of your projects. In case you generate you project from the default template, as shown above, your project will contain the placeholder for such dependency in the instantiate.jl file. Alternatively you can add dependencies from a (file) server: for this case, uncomment and adjust the corresponding line in instantiate.jl. ","category":"page"},{"location":"rc_example/#Toy-Example-#1:-Fit-exp-decay-curves","page":"Toy Example #1: Fit exp decay curves","title":"Toy Example #1: Fit exp decay curves","text":"","category":"section"},{"location":"rc_example/","page":"Toy Example #1: Fit exp decay curves","title":"Toy Example #1: Fit exp decay curves","text":"We read the both parameter tables and the data all from the same excel file. The data is a y(t) dependence containing several spans of exponential decay which we fit by non-linear least squares according to the formula a * exp(-(x-t₀)/τ), where t₀ is the span beginning and not fitted. The decay represents a capacitor discharge over a known resistor R. From τ, we get C, and by given area and ϵ we calculate the thickness of the capacitors dielectric.","category":"page"},{"location":"rc_example/","page":"Toy Example #1: Fit exp decay curves","title":"Toy Example #1: Fit exp decay curves","text":"We plot an overview plot of the data as well as plots of each span. The span start and end are the subset parameter from the table \"params_experiment\". The results are saved into two tables of an excel file: \"SubsetsRslt\" and \"summary\".","category":"page"},{"location":"rc_example/#Location-in-GivEmXL-project","page":"Toy Example #1: Fit exp decay curves","title":"Location in GivEmXL project","text":"","category":"section"},{"location":"rc_example/","page":"Toy Example #1: Fit exp decay curves","title":"Toy Example #1: Fit exp decay curves","text":"\"examples/RcExample\"","category":"page"},{"location":"rc_example/#User-interaction","page":"Toy Example #1: Fit exp decay curves","title":"User interaction","text":"","category":"section"},{"location":"rc_example/","page":"Toy Example #1: Fit exp decay curves","title":"Toy Example #1: Fit exp decay curves","text":"The user runs from from a terminal window a batch script rcex.sh / rcex.bat (invoking rcex.jl), to which he can optionally provide parameter -p / --plotformat, -e / --throwonerr, and -h / --help. These options are defined through the variable pp0::YAArguParser.ArgumentParser which is initialized in the file init_cli_options.jl. The user will be asked to point to \"his\" excel file with the parameters and data, and a GUI dialog opens. There are three excel files provided in the folder data/ of the example package. You may try it first with the file RcExampleData.xlsx.","category":"page"},{"location":"rc_example/","page":"Toy Example #1: Fit exp decay curves","title":"Toy Example #1: Fit exp decay curves","text":"Upon processing and saving the results, a corresponding message is printed, and either next file can be selected, or processing finished by typing -a / --abort. These interactions are defined by the variable pps, which is a NamedTuple of ArgumentParsers.","category":"page"},{"location":"rc_example/#Processing-functions","page":"Toy Example #1: Fit exp decay curves","title":"Processing functions","text":"","category":"section"},{"location":"rc_example/","page":"Toy Example #1: Fit exp decay curves","title":"Toy Example #1: Fit exp decay curves","text":"We define following functions in the file RcExample_specific.jl","category":"page"},{"location":"rc_example/","page":"Toy Example #1: Fit exp decay curves","title":"Toy Example #1: Fit exp decay curves","text":"preproc: Reads the data into a DataFrame to be passed downstream, and produces the overview plot-\nprocsubset: Does the fit on each span, and makes a plot.\npostproc: Applies DataFrames statistics to the results.","category":"page"},{"location":"rc_example/#User-invoked-script","page":"Toy Example #1: Fit exp decay curves","title":"User invoked script","text":"","category":"section"},{"location":"rc_example/","page":"Toy Example #1: Fit exp decay curves","title":"Toy Example #1: Fit exp decay curves","text":"The rcex.jl has just one executable line (apart from the using statements). We have already discussed most of the parameters passed to the complete_interact function. getexel=true and getdata=(; dialogtype = :none) tell that there should be a GUI dialog for excel file only.","category":"page"},{"location":"rc_example/#rc_err_proc","page":"Toy Example #1: Fit exp decay curves","title":"Error processing","text":"","category":"section"},{"location":"rc_example/","page":"Toy Example #1: Fit exp decay curves","title":"Toy Example #1: Fit exp decay curves","text":"There are two more excel files there: in MissingData.xlsx, some y values are missing in one of the spans, wheras in BrokenData.xlsx the expected data table is missing completely. In the first case, the data is processed as far as possible, and error information saved into the file named MissingData_err.txt, and in the second, only the file BrokenData_err.txt will be saved. If the flag --throwonerr was provided, the program would throw on the first error with the usual screenfull of information.","category":"page"},{"location":"rc_example/#Development-process","page":"Toy Example #1: Fit exp decay curves","title":"Development process","text":"","category":"section"},{"location":"rc_example/","page":"Toy Example #1: Fit exp decay curves","title":"Toy Example #1: Fit exp decay curves","text":"See file noninteractive_test.jl for how to supply the parameters to your processing functions in the course of the development process.","category":"page"},{"location":"api_user-interaction/#API-user-interaction","page":"API user interaction","title":"API user interaction","text":"","category":"section"},{"location":"api_user-interaction/","page":"API user interaction","title":"API user interaction","text":"The user interaction API is based on the YAArguParser package.","category":"page"},{"location":"api_user-interaction/","page":"API user interaction","title":"API user interaction","text":"The both functions proc_ARGS and prompt_and_parse take an ArgumentParser as an argument; they can also be passed Nothing - in this case the corresponding step will be skipped. Please see in our Toy Example for how to implement the user interaction in a typical case.","category":"page"},{"location":"api_user-interaction/#Flow-chart-overview","page":"API user interaction","title":"Flow chart - overview","text":"","category":"section"},{"location":"api_user-interaction/","page":"API user interaction","title":"API user interaction","text":"(Image: Overview)","category":"page"},{"location":"api_user-interaction/#Flow-chart-of-proc_ARGS()-function","page":"API user interaction","title":"Flow chart of proc_ARGS() function","text":"","category":"section"},{"location":"api_user-interaction/","page":"API user interaction","title":"API user interaction","text":"(Image: proc_args)","category":"page"},{"location":"api_user-interaction/#Flow-chart-of-prompt_and_parse()-function","page":"API user interaction","title":"Flow chart of prompt_and_parse() function","text":"","category":"section"},{"location":"api_user-interaction/","page":"API user interaction","title":"API user interaction","text":"(Image: prompt_and_parse)","category":"page"},{"location":"api_user-interaction/#User-julia-script","page":"API user interaction","title":"User julia script","text":"","category":"section"},{"location":"api_user-interaction/","page":"API user interaction","title":"API user interaction","text":"The script to be invoked by the used user can be as short as","category":"page"},{"location":"api_user-interaction/","page":"API user interaction","title":"API user interaction","text":"using MyBespokePackage\nusing GivEmXL\n\ncomplete_interact(pp0, pps, (preproc, procsubset, postproc); getexel=true, getdata=(; dialogtype = :none))","category":"page"},{"location":"api_user-interaction/","page":"API user interaction","title":"API user interaction","text":"For details, see complete_interact documentation and the first of the flow charts above. The parameter pp0 and pps, defining the user interaction, and the functions preproc, procsubset, postproc are to be defined in and exported from your package MyBespokePackage.","category":"page"},{"location":"api_user-interaction/#Batch-scripts","page":"API user interaction","title":"Batch scripts","text":"","category":"section"},{"location":"api_user-interaction/","page":"API user interaction","title":"API user interaction","text":"Batch scripts do nothing else but execute Julia in the environment you supplied, with the corresponding julia script.","category":"page"},{"location":"api_user-interaction/#Any-questions?","page":"API user interaction","title":"Any questions?","text":"","category":"section"},{"location":"api_user-interaction/","page":"API user interaction","title":"API user interaction","text":"Please analyze the Toy Examples.","category":"page"},{"location":"finally/#Release-Notes","page":"Finally","title":"Release Notes","text":"","category":"section"},{"location":"finally/#Release-0.2.2..0.2.7","page":"Finally","title":"Release 0.2.2..0.2.7","text":"","category":"section"},{"location":"finally/","page":"Finally","title":"Finally","text":"Some fixes. Added package docstring.","category":"page"},{"location":"finally/#Release-0.2.1","page":"Finally","title":"Release 0.2.1","text":"","category":"section"},{"location":"finally/","page":"Finally","title":"Finally","text":"2024-08-09 ","category":"page"},{"location":"finally/#New-features","page":"Finally","title":"New features","text":"","category":"section"},{"location":"finally/","page":"Finally","title":"Finally","text":"Add documentation for \"no excel file\" use case","category":"page"},{"location":"finally/#Other-changes","page":"Finally","title":"Other changes","text":"","category":"section"},{"location":"finally/","page":"Finally","title":"Finally","text":"Bug found and squashed here and there.","category":"page"},{"location":"finally/#Release-0.2.0","page":"Finally","title":"Release 0.2.0","text":"","category":"section"},{"location":"finally/","page":"Finally","title":"Finally","text":"2024-08-07 ","category":"page"},{"location":"finally/#New-features-2","page":"Finally","title":"New features","text":"","category":"section"},{"location":"finally/","page":"Finally","title":"Finally","text":"(Better) support for \"no excel file\" use case","category":"page"},{"location":"finally/#Other-changes-2","page":"Finally","title":"Other changes","text":"","category":"section"},{"location":"finally/","page":"Finally","title":"Finally","text":"Bug found and squashed here and there.","category":"page"},{"location":"finally/#Yet-lacking","page":"Finally","title":"Yet lacking","text":"","category":"section"},{"location":"finally/","page":"Finally","title":"Finally","text":"Documentation of new functionality.","category":"page"},{"location":"finally/#Release-0.1.0","page":"Finally","title":"Release 0.1.0","text":"","category":"section"},{"location":"finally/","page":"Finally","title":"Finally","text":"2024-07-18 initial release","category":"page"},{"location":"finally/#Likes-and-dislikes?","page":"Finally","title":"Likes & dislikes?","text":"","category":"section"},{"location":"finally/","page":"Finally","title":"Finally","text":"Star on GitHub, open an issue, contact me on Julia Discourse.","category":"page"},{"location":"finally/#Copyright-and-License","page":"Finally","title":"Copyright and License","text":"","category":"section"},{"location":"finally/","page":"Finally","title":"Finally","text":"(c) Eben60 2024","category":"page"},{"location":"finally/","page":"Finally","title":"Finally","text":"MIT License (see separate file LICENSE.md)","category":"page"},{"location":"noxl_example/#Toy-Example-#2:-Read-CSV,-no-excel","page":"Toy Example #2: Read CSV, no excel","title":"Toy Example #2: Read CSV, no excel","text":"","category":"section"},{"location":"noxl_example/","page":"Toy Example #2: Read CSV, no excel","title":"Toy Example #2: Read CSV, no excel","text":"We read one or multiple CSV files, plot the data and save the contents of these CSV files into (multiple) table(s) of an excel file.","category":"page"},{"location":"noxl_example/#Location-in-GivEmXL-project","page":"Toy Example #2: Read CSV, no excel","title":"Location in GivEmXL project","text":"","category":"section"},{"location":"noxl_example/","page":"Toy Example #2: Read CSV, no excel","title":"Toy Example #2: Read CSV, no excel","text":"\"examples/NoXLexample\"","category":"page"},{"location":"noxl_example/#User-interaction","page":"Toy Example #2: Read CSV, no excel","title":"User interaction","text":"","category":"section"},{"location":"noxl_example/","page":"Toy Example #2: Read CSV, no excel","title":"Toy Example #2: Read CSV, no excel","text":"The user runs from from a terminal window a batch script csvread.sh / csvread.bat (invoking csvread.jl), to which he can optionally provide parameter -s / --start, -l / --lastrow (defining the data subset), -e / --throwonerr, and -h / --help. These options are defined through the variable pp0::YAArguParser.ArgumentParser which is initialized in the file init_cli_options.jl. The user will be asked to point to \"his\" CSV file(s), and a GUI dialog opens. There are two CSV files provided in the folder data/ of the example package. ","category":"page"},{"location":"noxl_example/","page":"Toy Example #2: Read CSV, no excel","title":"Toy Example #2: Read CSV, no excel","text":"The type of the file dialog is defined in the line 22 of the file csvread.jl: dialogtype = :single. You can replace it by :multiple or :folder. In the last case, all CSV files in the selected folder will be processed.","category":"page"},{"location":"noxl_example/","page":"Toy Example #2: Read CSV, no excel","title":"Toy Example #2: Read CSV, no excel","text":"Upon processing and saving the results, a corresponding message is printed, and either next file can be selected, or processing finished by typing -a / --abort. These interactions are defined by the variable pps, which is a NamedTuple of ArgumentParsers.","category":"page"},{"location":"noxl_example/#Processing-functions","page":"Toy Example #2: Read CSV, no excel","title":"Processing functions","text":"","category":"section"},{"location":"noxl_example/","page":"Toy Example #2: Read CSV, no excel","title":"Toy Example #2: Read CSV, no excel","text":"We define following just one processing function in the file NoXLexample_specific.jl","category":"page"},{"location":"noxl_example/","page":"Toy Example #2: Read CSV, no excel","title":"Toy Example #2: Read CSV, no excel","text":"preproc: Reads the CSV data into DataFrames to be passed downstream, and produces plots","category":"page"},{"location":"noxl_example/","page":"Toy Example #2: Read CSV, no excel","title":"Toy Example #2: Read CSV, no excel","text":"procsubset and postproc are both set to nothing in csvread.jl","category":"page"},{"location":"noxl_example/#User-invoked-script","page":"Toy Example #2: Read CSV, no excel","title":"User invoked script","text":"","category":"section"},{"location":"noxl_example/","page":"Toy Example #2: Read CSV, no excel","title":"Toy Example #2: Read CSV, no excel","text":"The csvread.jl calls complete_interact function. We have already discussed most of the parameters passed to it function. getexel=false and getdata=(; dialogtype = :single, filterlist=\"csv\") tell that there should be a GUI dialog for data file(s) only.","category":"page"},{"location":"noxl_example/#Error-processing","page":"Toy Example #2: Read CSV, no excel","title":"Error processing","text":"","category":"section"},{"location":"noxl_example/","page":"Toy Example #2: Read CSV, no excel","title":"Toy Example #2: Read CSV, no excel","text":"There are two more excel files there: in MissingData.xlsx, some y values are missing in one of the spans, wheras in BrokenData.xlsx the expected data table is missing completely. In the first case, the data is processed as far as possible, and error information saved into the file named MissingData_err.txt, and in the second, only the file BrokenData_err.txt will be saved. ","category":"page"},{"location":"noxl_example/","page":"Toy Example #2: Read CSV, no excel","title":"Toy Example #2: Read CSV, no excel","text":"If the flag --throwonerr was provided, the program would throw on the first error with the usual screenfull of information, otherwise the data will processed as far as possible, and error information saved into a file in the results folder.","category":"page"},{"location":"noxl_example/#Development-process","page":"Toy Example #2: Read CSV, no excel","title":"Development process","text":"","category":"section"},{"location":"noxl_example/","page":"Toy Example #2: Read CSV, no excel","title":"Toy Example #2: Read CSV, no excel","text":"See file noninteractive_test.jl for how to supply the parameters to your processing functions in the course of the development process.","category":"page"},{"location":"api_data-processing/#API-data-processing","page":"API data processing","title":"API data processing","text":"","category":"section"},{"location":"api_data-processing/","page":"API data processing","title":"API data processing","text":"In a general case your calculation would processes multiple data subsets, wherein the processing is performed in three steps: preprocessing, processing of each subset in a loop, and postprocessing. Each step can be however skipped. Specifically if your data are not divided into subsets, you would put everything into the \"preprocessing\" function.","category":"page"},{"location":"api_data-processing/","page":"API data processing","title":"API data processing","text":"You have to provide the corresponding functions for each of the steps, except skipped ones. You have the free choice in respect to the names of these functions. Results of each step are merged with the results of the previous one and passed to the following one. The processing data and saving results is performed by the function proc_n_save, which calls the functions proc_data and save_results, respectively. The results are saved into a sub-directory of the excel file folder, and contain plots, the multi-table results file in XLSX format, and, in case of errors, a text file with errors information.","category":"page"},{"location":"api_data-processing/#Parameter-passed-to-data-processing-functions","page":"API data processing","title":"Parameter passed to data processing functions","text":"","category":"section"},{"location":"api_data-processing/","page":"API data processing","title":"API data processing","text":"xlfile::String: path to the exel file (in general case, Union{Nothing, String})\ndatafiles::Nothing: we put our data into the same exel file (in general case, Union{Nothing, String, Vector{String}})\nparamsets::Vector{NamedTuple}: In our case, there will be 3 NamedTuples, one for each row of the table params_experiment. Each NamedTuple will contain the data as defined in the corresponding row as well a (repeating) data from the user input (here only plotformat defined) and the table table params_experiment, e.g. ","category":"page"},{"location":"api_data-processing/","page":"API data processing","title":"API data processing","text":"julia> paramsets[1]\n(plotformat = \"png\", throwonerr = true, area = 0.5 cm², Vunit = mV, timeunit = s, Cunit = nF, R = 5 GΩ, t_start = 1 s, t_stop = 4 s, ϵ = 3.7, no = 1, plot_annotation = \"first discharge\", comment = \"first discharge – 1\")","category":"page"},{"location":"api_data-processing/#Preprocessing","page":"API data processing","title":"Preprocessing","text":"","category":"section"},{"location":"api_data-processing/","page":"API data processing","title":"API data processing","text":"The preprocessing function must take three arguments discussed above, like fn_preproc(xlfile, datafiles, paramsets), and expected to return a NamedTuple as following (;plots, dataframes, data):","category":"page"},{"location":"api_data-processing/","page":"API data processing","title":"API data processing","text":"plots::Union{Nothing, NamedTuple{(:plot_annotation, plots...)}}: e.g. (;plot_annotation=\"overview\", ov1=pl1, ov2=pl2) - here pl1 and pl2 are plot objects. The annotation will be a part of the file name(s), and if there are multiple plots, their names (e.g. pl1) will be compounded into the file name, too. Each plot will be eventually saved to a separate file.\ndataframes::Union{Nothing, NamedTuple{(dataframes...)}}: e.g. (; overview_table=df1). Each dataframe will be saved into a correspondingly named table of the results file in XLSX format.\ndata::Any: The data to be passed to the following processing steps.","category":"page"},{"location":"api_data-processing/#Subset-processing","page":"API data processing","title":"Subset processing","text":"","category":"section"},{"location":"api_data-processing/","page":"API data processing","title":"API data processing","text":"The subset processing function must take arguments like following: fn_subset(i, pm_subset, overview, xlfile, datafiles, paramsets):","category":"page"},{"location":"api_data-processing/","page":"API data processing","title":"API data processing","text":"i: Subset number.\npm_subset=paramsets[i]: For paramsets, see above (and yes, I know, it's kind of redundant).\noverview::NamedTuple{(:plots, :dataframes, :data)}: NamedTuple as returned by the preprocessing function.\nfor the rest of the arguments, see above.","category":"page"},{"location":"api_data-processing/","page":"API data processing","title":"API data processing","text":"It is expected to return a NamedTuple as following (;rs, df_row):","category":"page"},{"location":"api_data-processing/","page":"API data processing","title":"API data processing","text":"rs::NamedTuple{(:subset, :plot_annotation, plots..., more results... )}: Where subset=i, and plot_annotation and plots... have the same meaning as for preprocessing.\ndf_row::NamedTuple: The subset results to be afterwards concatenated into a DataFrame and saved as a table of an excel file.","category":"page"},{"location":"api_data-processing/#Postprocessing","page":"API data processing","title":"Postprocessing","text":"","category":"section"},{"location":"api_data-processing/","page":"API data processing","title":"API data processing","text":"The postprocessing function must take arguments like following: fn_postproc(xlfile, datafiles, paramsets, overview, subsets_results):","category":"page"},{"location":"api_data-processing/","page":"API data processing","title":"API data processing","text":"subsets_results::Vector{NamedTuple{(:rs, :df_row)}}: Concatenation of subset processing results.\nfor all other parameters, see above.","category":"page"},{"location":"api_data-processing/","page":"API data processing","title":"API data processing","text":"It is expected to return a NamedTuple as following (;plots, :dataframes) - see Preprocessing above for details.","category":"page"},{"location":"api_data-processing/#Plot-objects","page":"API data processing","title":"Plot objects","text":"","category":"section"},{"location":"api_data-processing/","page":"API data processing","title":"API data processing","text":"If your data processing functions return Plots or Makie objects, that is supported out of the box. If you use some other package, or maybe want to save some other objects instead of or additionally to the plots, you have to define your own methods for two functions like following (see also package extension files in the GivEmXL's folder ext/ as an example):","category":"page"},{"location":"api_data-processing/","page":"API data processing","title":"API data processing","text":"import GivEmXL: isplot, save_plot\nusing Foo # you favorite plotting package\n\nisplot(::Foo.foo_plot) = true\nsave_plot(pl::::Foo.foo_plot, fl) = Foo.saveplot(pl, fl)","category":"page"},{"location":"api_data-processing/#Example","page":"API data processing","title":"Example","text":"","category":"section"},{"location":"api_data-processing/","page":"API data processing","title":"API data processing","text":"All three processing steps:","category":"page"},{"location":"api_data-processing/","page":"API data processing","title":"API data processing","text":"function my_preproc(args...; kwargs...) \n    # do the job\nreturn\n\nfunction my_proc_subset(args...; kwargs...) \n    # do the job\nreturn\n\nfunction my_postproc(args...; kwargs...) \n    # do the job\n\ncomplete_interact(pp0, pps, (my_preproc, my_proc_subset, my_postproc); getexel=true, getdata=(; dialogtype = :none))","category":"page"},{"location":"api_data-processing/","page":"API data processing","title":"API data processing","text":"One processing step:","category":"page"},{"location":"api_data-processing/","page":"API data processing","title":"API data processing","text":"function my_proc_everything(args...; kwargs...) \n    # do the job\nreturn\n\ncomplete_interact(pp0, pps, (my_proc_everything, nothing, nothing); getexel=true, getdata=(; dialogtype = :none))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: License: MIT) (Image: Lifecycle:Maturing) (Image: Documentation)  (Image: Build Status)  (Image: Coverage)  (Image: Aqua QA)","category":"page"},{"location":"#GivEmXL-build-your-poor-man's-interactive-app","page":"Introduction","title":"GivEmXL - build your poor man's interactive app","text":"","category":"section"},{"location":"#Package-purpose","page":"Introduction","title":"Package purpose","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Let's assume you are the only Julia  user/programmer among your colleagues. Maybe the only one who does programming at all – all others mostly use Microsoft® Excel® [smallprint] for their computations, or else some specialized (GUI) software. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[smallprint]: throughout the text, \"excel file\" (no capitalisation) and \"XLSX file\" will be used interchangeably and denote files in the XLSX format, which can be produced and read by MS Excel as well as other software, e.g. LibreOffice.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Now, you have developed a script for some computation or data analysis which they would be glad to use – but asking them to accept your programmers workflow would be asking too much. Building a full GUI for your script to be used by merely a couple of users would be an time-consuming overkill. Enter GivEmXL: with this package you are able to produce \"somewhat interactive\" packages for use by your non-programming colleagues.","category":"page"},{"location":"#Another-package-purpose","page":"Introduction","title":"Another package purpose","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"My motivation was actually initially different. I used a Julia script to process experimental data, and for each experiment there were about a dozen or so of experiment-specific parameter plus a dozen of parameters specific for each separate measurement within the experiment. For each measurement, my script produced a further dozen of numbers. Using MS Excel proved to be a practical way to manage the parameter and results and to share them with the colleagues. Then with a bit of additional programming I could also share the script itself and let them process their data on their own: That happened to be a nice side effect.","category":"page"},{"location":"#Toy-example-evaluation-of-capacitor-discharge-curves","page":"Introduction","title":"Toy example - evaluation of capacitor discharge curves","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"See the source under examples/RcExample","category":"page"},{"location":"#From-the-user's-point-of-view","page":"Introduction","title":"From the user's point of view","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Your colleague receives from you","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Instructions for Julia installation on their computer\nAn excel template file containing one or two tables\nA folder (or zip file) to be copied/extracted somewhere onto their computer. The folder contains two batch files (.bat on Windows an .sh on unixes), and some other folder enclosed. One of the batch files is instantiate.bat/instantiate.sh to be run once.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Let's look into the contents of the Excel files. The first of them is called param_setup and contains the default values (here for area and ϵ) and the units like following:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"area Vunit timeunit Cunit R t_start t_stop ϵ\n0.5       3.7\n\"cm^2\" \"mV\" \"s\" \"nF\" \"GΩ\" \"s\" \"s\" ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The second one is params_experiment with the following contents:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"no plot_annotation comment t_start t_stop R ϵ\n1 first discharge first discharge – 1 1 4 5 \n2 second discharge second discharge – 2 6 12 5 \n3 third discharge third discharge – 3 14 20 0.5 4.5","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Those are the respective parameters for three data subsets to be analysed. Note that the cells in the first two rows of the last column (ϵ) are empty, meaning the default value as defined in the previous table will be used.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In this case the actual data are added by the user as the third table of the same excel file.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The user then runs in the terminal another batch file, here called rcex.bat, and gets the following dialog.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"eben@Macni2020M1 RcExample % ./rcex.sh \npress <ENTER>, then select excel file.\nRcExample> ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Here a file selection dialog opens for the user to point to the formerly prepared excel file. You select the file, it will be processed, and you will be prompted for the next one:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Completed processing /Users/eben/Julia/GivEmXL.jl/examples/RcExample/RcExample.jl/data/RcExampleData.xlsx\npress <ENTER> to process next file, of -a<ENTER> to abort \nRcExample> -a\neben@Macni2020M1 RcExample % ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If unsure, it is possible to enter -h or --help at any stage of the dialog.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"As soon as the selected file is processed, the results will be put into a folder named YourExcelFileName_rslt: There will be an excel file with the processing results (in this case containing two tables: one table with one results row per subset, and the summary table), and some graphic files: in this case an overview plot and one plot for each subset.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Clean your data, rinse, repeat 😁","category":"page"},{"location":"#From-the-developer's-point-of-view","page":"Introduction","title":"From the developer's point of view","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"After, or in the course of, finishing to program what your package is expected to do, define the parameter and units to be communicated to your app. Those can be transferred by way of CLI parameter, or through a file in XLSX format. In our toy example the plotting format can be passed as CLI parameter, e.g.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"$ >  rcex.sh --plotformat PDF","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"whereas for the experiment parameters like area and ϵ, we use excel. However, in the end the CLI input will be merged with the excel input and passed to your functions as kwargs...","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In our example, the experimental data are in a separate table in the same excel file. We could also let the user to point to a separate file or folder, or conclude to the data file from the name or position of the excel file.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"It is assumed (but not required) that your calculation processes multiple data subsets: In our example there are three segments (three capacitor discharges).  We divide our processing into three separate functions: Preprocessing / processing each subset / postprocessing. In our toy example these functions are: preproc, procsubset, postproc. You can however skip some steps if you don't need them. In our toy example you can uncomment the line ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"# postproc = nothing ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"just with the effect that no summary will now be produced. Our functions are expected to return dataframes or dataframe rows, and plot objects. In our example, we use Plots.jl. Makie.jl is also supported out of the box. For other plotting packages, you will need to add a few code lines.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The returned dataframes will be saved as an excel file with multiple tables, the plots saved in the selected format. Voilà!","category":"page"},{"location":"docstrings/#Exported-Functions","page":"Docstrings","title":"Exported Functions","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Modules = [GivEmXL]\nPrivate = false\nOrder   = [:function, ]","category":"page"},{"location":"docstrings/#GivEmXL.complete_interact-Tuple{Any, Any, Function}","page":"Docstrings","title":"GivEmXL.complete_interact","text":"complete_interact(pp0, pps, proc_data_fn::Function; kwargs...) → nothing\ncomplete_interact(pp0, pps, proc_data_fns::Tuple; kwargs...) → nothing\n\nThis is the top level function for building the interaction with the user. See the flow diagram in the documentation for details. It calls proc_ARGS first, prompt_and_parse multiple times, and lets user pick file(s) by a GUI.  The inputs are merged with the parameter in the excel file, and all that passed to user-provided function(s) to perform the data processing.\n\nArguments\n\npp0::Union{Nothing, ArgumentParser}: ArgumentParser for command line arguments.\npps::NamedTuple: ArgumentParsers for individual dialogs. The corresponding keys are:    [:gen_options, :spec_options, :exelfile_prompt, :datafiles_prompt, :next_file]. To skip a dialog, skip the key.\nproc_data_fn(; xlfile, datafiles, paramsets)::Function: Function to do the actual data processing. It takes these three kwargs.\nproc_data_fns::Tuple: Alternatively a tuple of three functions can be provides:    For preprocessing, processing a subset, and postprocessing. See also proc_data\n\nKeyword arguments\n\nbasedir=nothing: The base directory for the file selection dialogs. If basedir not provided, uses the cached value.\nparamtables = (;setup=\"params_setup\", exper=\"params_experiment\"): The names of the tables containing the corresponding parameters.   Set a table to nothing to skip it.\ngetexel=false: If true, execute excel file selection dialog.\ngetdata=(; dialogtype = :none): If :none, no data file selection dialog,    otherwise the parameter will be passed to the get_data function to execute file/directory selection dialog.\n\nFunction complete_interact is exported.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GivEmXL.exper_paramsets","page":"Docstrings","title":"GivEmXL.exper_paramsets","text":"exper_paramsets(userargs, df_exp, df_setup) → Vector{NamedTuple}\n\nMerges userargs with the parameter in df_setup and in each row of df_exp\n\nArguments\n\nuserargs: Arguments (e.g. as NamedTuple) \ndf_exp::Union{Nothing, DataFrame}: Experiment (subsets) parameter, as read from an excel file.\ndf_setup::Union{Nothing, DataFrame}: Experiment setup parameter, as read from an excel file. \n\nFunction exper_paramsets is exported.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#GivEmXL.proc_n_save-Tuple{Any, Any, Any}","page":"Docstrings","title":"GivEmXL.proc_n_save","text":"proc_n_save(procwhole_fn, procsubset_fn, postproc_fn;\n    xlfile,\n    datafiles=nothing, \n    paramsets = [(;)],\n    ) → (; overview, subsets_results, résumé, errors, dfs)\n\nCalls proc_data with the user provided functions to process data followed by save_results.  For explanation of arguments and returned values see docs on these functions.\n\nFunction proc_n_save is exported.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GivEmXL.read_xl_paramtables-Tuple{Any}","page":"Docstrings","title":"GivEmXL.read_xl_paramtables","text":"read_xl_paramtables(f_src; paramtables=(;setup=\"params_setup\", exper=\"params_experiment\")) \n    → (; df_setup::Union{Nothing, DataFrame}, df_exp::Union{Nothing, DataFrame})\n\nReads the two tables (if not nothing) from an XLSX file into corresponding DataFrames and strips comments, if any.  Comment is any row starting with # \n\nArgument\n\nf_src::String: File path\n\nKeyword argument\n\nparamtables=(;setup::Union{Nothing, String}=\"params_setup\", exper::Union{Nothing, String}=\"params_experiment\")\n\nReturned NamedTuple\n\n(;df_setup::Union{Nothing, DataFrame}, df_exp::Union{Nothing, DataFrame}\n\nFunction read_xl_paramtables is exported.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Public-and-Internal-Functions","page":"Docstrings","title":"Public and Internal Functions","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Modules = [GivEmXL]\nPublic = false\nOrder   = [:function, ]","category":"page"},{"location":"docstrings/#GivEmXL.combine2df-Tuple{Any}","page":"Docstrings","title":"GivEmXL.combine2df","text":"combine2df(subsets_results) → Union{DataFrame, Nothing}\n\nCombines NamedTuples (or equivalent) into a dataFrame.\n\nFunction combine2df is public, not exported.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GivEmXL.get_data-Tuple{}","page":"Docstrings","title":"GivEmXL.get_data","text":"get_data(;dialogtype, filterlist=\"\", datadir=nothing) \n    → (; abort::Bool, datafiles)\n\nCalls the function NativeFileDialog: pick_file(datadir; filterlist) or pick_multi_file(datadir; filterlist).  If datadir not provided, uses the cached value. Caches the selected directory. Returns file or folder or multiple files.\n\nKeyword arguments\n\ndialogtype: dialogtype ∈ [:single, :multiple, :folder]\ndatadir: The base directory for file selection dialog.\nfilterlist: Will be passed to pick_file / pick_multi_file function.\n\nThrows\n\nOn unknown value of dialogtype\n\nFunction get_data is public, not exported.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GivEmXL.get_xl-Tuple{}","page":"Docstrings","title":"GivEmXL.get_xl","text":"get_xl(; basedir=nothing, paramtables = (;setup=\"params_setup\", exper=\"params_experiment\")) \n    → (;abort, xlargs=rslt, fname)\n\nCalls the function NativeFileDialog: pick_file(datadir; filterlist) to select an XLSX.  Passes the file to read_xl_paramtables to parse the parameter table(s) If basedir not provided, uses the cached value. Caches the selected directory. \n\nKeyword arguments\n\ndialogtype: dialogtype ∈ [:single, :multiple, :folder]\nbasedir: The base directory for file selection dialog.\n\nReturned NamedTuple\n\nabort::Bool: Dialog cancelled by user\nxlargs::NamedTuple: Tables read into DataFrames - s. read_xl_paramtables\nfname::String: Selected XLSX file\n\nFunction get_xl is public, not exported.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GivEmXL.makeproj","page":"Docstrings","title":"GivEmXL.makeproj","text":"makeproj(tgt_folder, tgt_projname, tgt_scriptname, src::NamedTuple; \n    ignorecase=false, authors::Vector{String}=String[], force=false) → nothing\nmakeproj(tgt_folder, tgt_projname, tgt_scriptname, src::Symbol; kwargs...)\n\nCreate a project by copying a template project and performing renamings as necessary. Destination folder must be different from the enclosing folder of the source.\n\nArguments\n\ntgt_folder::AbstractString: Destination folder\ntgt_projname::AbstractString: The name of the project to be created\ntgt_scriptname::AbstractString: The name of the executable script\nsrc::Symbol: Accepts either :default (the default template), or :example1    for Toy Example #1, or :example2 for Toy Example #2 provided with GivEmXL\nsrc::@NamedTuple{src_folder::String, src_scriptname::String}: E.g. it would be    src=(; src_folder=\"userproj_template/Template_ProjName\", src_scriptname=\"template_user_scriptname\")    for the default template\n\nKeyword arguments\n\nignorecase=false: Ignore case in the file paths\nauthors::Vector{T}=String[] where T <: AbstractString: The project authors (goes to Project.toml)\nforce=false: If true, will overwrite the destination.\n\nFunction makeproj is public, not exported.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#GivEmXL.merge_params-Tuple{Any, Any, Any}","page":"Docstrings","title":"GivEmXL.merge_params","text":"merge_params(df_exp::Union{Nothing, DataFrame}, df_setup::Union{Nothing, DataFrame}, row::Integer) → (;nt, nt_exp, nt_setup, nt_unitless)\n\nMerges default parameters and units from df_setup with the parameter in the given row of df_exp, and returns them as NamedTuple of NamedTuples.  Actually only the nt field of the returned value is used.\n\nFunction merge_params is public.\n\nExamples\n\njulia> m = GivEmXL.merge_params(df_exp, df_setup, 1);\njulia> m.nt\n(area = 0.5 cm², Vunit = mV, timeunit = s, Cunit = nF, R = 5 GΩ, t_start = 1 s, t_stop = 4 s, ϵ = 3.7, no = 1, plot_annotation = \"first discharge\", comment = \"first discharge – 1\")\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GivEmXL.mergent-Tuple{Any}","page":"Docstrings","title":"GivEmXL.mergent","text":"mergent(args::Array) → ::NamedTuple\nmergent(args...) → ::NamedTuple\n\nMerges multiple NamedTuples, or arguments convertible to NamedTuples (e.g. Dict, pairs).\n\nFunction mergent is internal.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GivEmXL.nt2unitful-Tuple{Any, Any}","page":"Docstrings","title":"GivEmXL.nt2unitful","text":"nt2unitful(nt, ntunits) → NamedTuple\n\nApplies units from ntunits to the values from nt\n\nFunction nt2unitful is internal.\n\nExamples\n\njulia> nt2unitful((; a=2.0, b=3), (;a=u\"cm/s\"))\n(a = 2.0 cm s⁻¹, b = 3)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GivEmXL.out_paths-Tuple{Any}","page":"Docstrings","title":"GivEmXL.out_paths","text":"out_paths(f_src) → (;fname, f_src, src_dir, rslt_dir, outf, errf)\n\nFrom given source path, generates names and paths used for sources and results.\n\nFunction out_paths is public, not exported.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GivEmXL.parse_cl_string-Tuple{Any}","page":"Docstrings","title":"GivEmXL.parse_cl_string","text":"parse_cl_string(s::AbstractString) →  ::String[]\n\nWrapper around Base.shell_split\n\nFunction parse_cl_string is public, not exported.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GivEmXL.proc_ARGS-Tuple{Any}","page":"Docstrings","title":"GivEmXL.proc_ARGS","text":"proc_ARGS(pp0::Nothing) = (;abort=false, argpairs = emptyargs())\nproc_ARGS(pp0::ArgumentParser) → (;abort, argpairs)\n\nReads and parses the arguments provided to the script from the command line. See the flow diagram in the documentation for details.\n\nArguments\n\npp0::Union{Nothing, ArgumentParser}: ArgumentParser for command line arguments.\n\nReturned NamedTuple\n\nabort::Bool\nargpairs: Vector of pairs argname::Symbol => argvalue::Any\n\nFunction proc_ARGS is public, not exported.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GivEmXL.proc_data-NTuple{6, Any}","page":"Docstrings","title":"GivEmXL.proc_data","text":"proc_data(xlfile, datafiles, paramsets, procwhole_fn, procsubset_fn, postproc_fn; throwonerr=false) \n    → (; overview, subsets_results, résumé, errors)\n\nCalls the user provided data processing functions.\n\nArguments\n\nxlfile: XLSX file (if any)\ndatafiles: Data file(s) or folder (if any)\nparamsets::Vector{NamedTuple}: Parameter merged from those supplied by user as cli arguments and those contained in the excel file.\nprocwhole_fn::Union{Nothing, Function}: User supplied function for preprocessing\nprocsubset_fn::Union{Nothing, Function}: User supplied function for processing a data subset\npostproc_fn::Union{Nothing, Function}: User supplied function for postprocessing\n\nKeyword arguments\n\nthrowonerr=false: If true, Julia execution will stop on an error and print error information, otherwise execution continues    and error information can be saved into a separate file.\n\nReturned NamedTuple\n\noverview::NamedTuple: May contain DataFrame(s) and plot objects as returned by procwhole_fn function\nsubsets_results::Vector{NamedTuple}: May contain a DataFrame row and plot objects for each subset as returned by procsubset_fn\nrésumé::NamedTuple: May contain DataFrame(s) and plot objects as returned by postproc_fn function\nerrors::Vector{NamedTuple}: Collects information on errors if any occurred.\n\nFunction proc_data is public, not exported.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GivEmXL.prompt_and_parse-Tuple{Any}","page":"Docstrings","title":"GivEmXL.prompt_and_parse","text":"prompt_and_parse(pp::Nothing) = (;abort=false, argpairs = emptyargs())\nprompt_and_parse(pp::ArgumentParser) → (;abort, argpairs)\n\nPrints a prompt, read and parses the input from the user. See the flow diagram in the documentation for details.\n\nArguments\n\npp::Union{Nothing, ArgumentParser}: ArgumentParser for command line arguments.\n\nReturned NamedTuple\n\nabort::Bool\nargpairs: Vector of pairs argname::Symbol => argvalue::Any\n\nFunction prompt_and_parse is public, not exported.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GivEmXL.read_units-Tuple{Any}","page":"Docstrings","title":"GivEmXL.read_units","text":"read_units(df_setup::DataFrame) → NamedTuple\nread_units(d::Nothing) = (;)\n\nFunction read_units is internal.\n\nExamples\n\njulia> GivEmXL.read_units(df_setup)\n(area = cm², Vunit = mV, timeunit = s, Cunit = nF, R = GΩ, t_start = s, t_stop = s, ϵ = missing)\n\njulia> typeof(ans.timeunit)\nUnitful.FreeUnits{(s,), 𝐓, nothing}\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GivEmXL.remove_comments-Tuple{Any}","page":"Docstrings","title":"GivEmXL.remove_comments","text":"remove_comments(df::DataFrame) → ::DataFrame\n\nComment is any row starting with # - these rows will be omitted.\n\nFunction remove_comments is internal.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GivEmXL.s2unit-Tuple{Any}","page":"Docstrings","title":"GivEmXL.s2unit","text":"s2unit(str::AbstractString) → ::Quantity\n\nStrips all kinds of quotation marks and parses a string into Quantity.  See also Unitful.uparse\n\nThrows\n\nOn conversion error\n\nFunction s2unit is internal.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GivEmXL.save_all_plots-NTuple{5, Any}","page":"Docstrings","title":"GivEmXL.save_all_plots","text":"save_all_plots(overview, subsets_results, résumé, rslt_dir, paramsets) → nothing\n\nSaves plot objects as generated by the three data processing functions into files of given format.\n\nArguments\n\noverview, subsets_results, résumé::NamedTuple: Results of actual data processing in the form (; plots=(;df1, df2...), ...).    The key 'plots' is optional.\nrslt_dir: directory where to put files.\nparamsets::Vector{NamedTuple}: If paramsets[1] has field plotformat, it will be the format for saving plots. \n\nFunction save_all_plots is public, not exported.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GivEmXL.save_dfs-NTuple{4, Any}","page":"Docstrings","title":"GivEmXL.save_dfs","text":"save_dfs(overview, subsets_results, résumé, outf) → NamedTuple\n\nSaves DataFrames as generated by the three data processing functions into (multiple) tables of an XLSX file\n\nArguments\n\noverview, subsets_results, résumé::NamedTuple: Results of actual data processing in the form (; dataframes=(;df1, df2...), ...).    The key 'dataframes' is optional.\noutf: target XLSX file.\n\nReturns\n\ndfs: a NamedTuple of DataFrames\n\nFunction save_dfs is public, not exported.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GivEmXL.save_results-NTuple{4, Any}","page":"Docstrings","title":"GivEmXL.save_results","text":"save_results(results, xlfile, paramsets) → (;dfs)\n\nCalls the functions save_dfs, save_all_plots, write_errors to save the results and errors.\n\nArguments\n\nresults: NamedTuple having structure (; overview, subsets_results, résumé, errors)\noverview, subsets_results, résumé::NamedTuple: Results of actual data processing in the form (; plots=(;df1, df2...), ...).    The key 'plots' is optional.\nxlfile: Path to the XLSX file with the parameter.\nparamsets::Vector{NamedTuple} \n\nReturned value\n\n(;dfs): A NamedTuple of DataFrames as returned by save_dfs \n\nFunction save_results is public, not exported.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GivEmXL.saveplots-Tuple{Any, Any}","page":"Docstrings","title":"GivEmXL.saveplots","text":"saveplots(rs, rslt_dir; plotformat = \"png\", kwargs...) → nothing\n\nSaves plot objects as generated by a data processing function into files of given format.\n\nArguments\n\nrs: NamedTuple with the processing results.\nrslt_dir: directory where to put files. \n\nKeyword arguments\n\nplotformat = \"png\": If plotformat == \"none\", do not save.\nOther kwargs will be ignored.\n\nFunction saveplots is public, not exported.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GivEmXL.write_errors-Tuple{Any, Any}","page":"Docstrings","title":"GivEmXL.write_errors","text":"write_errors(errf, errors) → errored::Bool\n\nSaves backtraces of errors into a file.\n\nArguments\n\nerrf: File where errors will be saved.\nerrors: Array of backtraces\n\nReturns\n\nerrored: false if errors was an empty array.\n\nFunction write_errors is public, not exported.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#GivEmXL.write_xl_tables-Tuple{Any, Any}","page":"Docstrings","title":"GivEmXL.write_xl_tables","text":"write_xl_tables(fl, nt_dfs; overwrite=true) → Nothing\n\nWrites multiple DataFrames into an XLSX file.\n\nArguments\n\nfl: target XLSX file.\nnt_dfs::NamedTuple: DataFrames to save. nt_dfs keys will map to table names.  \n\nFunction write_xl_tables is public, not exported.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Index","page":"Docstrings","title":"Index","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"","category":"page"}]
}
